var documenterSearchIndex = {"docs":
[{"location":"man/logger_guide/#Logging","page":"Logging","title":"Logging","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"The function custom_logger is a wrapper over the Logging.jl and LoggingExtras.jl libraries. I made them such that I could fine tune the type of log I use repeatedly across projects. ","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"The things I find most useful:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"four different log files for each different level of logging from error to debug\npretty (to me) formatting for stdout but also an option to have log4j style formatting in the files\nfiltering out messages of verbose packages (TranscodingStreams, etc...) which sometimes slows down julia because of excessive logging.","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"There are still a few things that might be useful down the line: (1) a catch-all log file where filters do not apply; (2) filtering out specific functions of packages; ","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"Overall this is working fine for me.","category":"page"},{"location":"man/logger_guide/#Basic-usage","page":"Logging","title":"Basic usage","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"Say at the beginning of a script you would have something like:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"using BazerUtils\ncustom_logger(\"/tmp/log_test\"; \n    filtered_modules_all=[:StatsModels, :TranscodingStreams, :Parquet2], \n    create_log_files=true, \n    overwrite=true, \n    log_format = :log4j);\n  \n┌ Info: Creating four different files for logging ...\n│  ⮑  /tmp/log_test_error.log\n│      /tmp/log_test_warn.log\n│      /tmp/log_test_info.log\n└      /tmp/log_test_debug.log","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"The REPL will see all messages above debug level:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"> @error \"This is an error level message\"\n┌ [08:28:08 2025-02-12] ERROR |  @ Main[REPL[17]:1]\n└ This is an error level message\n\n> @warn \"This is an warn level message\"\n┌ [08:28:08 2025-02-12] WARN  |  @ Main[REPL[18]:1]\n└ This is an warn level message\n\n> @info \"This is an info level message\"\n┌ [08:28:08 2025-02-12] INFO  |  @ Main[REPL[19]:1]\n└ This is an info level message\n\n> @debug \"This is an debug level message\"\n","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"Then each of the respective log-levels will be redirected to the individual files and if the log4j option was specified they will look like something like this","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"2025-02-12 08:28:08 ERROR Main[REPL[17]:1] - This is an error level message\n2025-02-12 08:28:08 WARN  Main[REPL[18]:1] - This is an warn level message\n2025-02-12 08:28:08 INFO  Main[REPL[19]:1] - This is an info level message\n2025-02-12 08:28:08 DEBUG Main[REPL[20]:1] - This is an debug level message","category":"page"},{"location":"man/logger_guide/#Options","page":"Logging","title":"Options","text":"","category":"section"},{"location":"man/logger_guide/#Formatting","page":"Logging","title":"Formatting","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"The log_format is log4j by default (only for the files).  The only other option for now is pretty which uses the format I wrote for the REPL; note that it is a little cumbersome for files especially since you have to make sure your editor has the ansi interpreter on. ","category":"page"},{"location":"man/logger_guide/#Files","page":"Logging","title":"Files","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"The default is to create one file for each level.  There is an option to only create one file for each level and keep things a little tidier in your directories:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"> custom_logger(\"/tmp/log_test\";  \n    create_log_files=false, overwrite=true, log_format = :log4j);\n\n> @error \"This is an error level message\" \n> @warn \"This is an warn level message\"\n> @info \"This is an info level message\"\n> @debug \"This is an debug level message\"","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"And then the file /tmp/log_test has the following:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"2025-02-12 08:37:29 ERROR Main[REPL[22]:1] - This is an error level message\n2025-02-12 08:37:29 WARN  Main[REPL[23]:1] - This is an warn level message\n2025-02-12 08:37:29 INFO  Main[REPL[24]:1] - This is an info level message\n2025-02-12 08:37:29 DEBUG Main[REPL[25]:1] - This is an debug level message","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"Now imagine you want to keep the same log file but for a different script.  You can use the same logger option with the overwrite=false option:","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"> custom_logger(\"/tmp/log_test\";  \n    create_log_files=false, overwrite=false, log_format = :log4j);\n\n> @error \"This is an error level message from a different script and new logger\" ","category":"page"},{"location":"man/logger_guide/#Filtering","page":"Logging","title":"Filtering","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"filtered_modules_specific::Vector{Symbol}=nothing: which modules do you want to filter out of logging (only for info and stdout) Some packages just write too much log ... filter them out but still be able to check them out in other logs\nfiltered_modules_all::Vector{Symbol}=nothing: which modules do you want to filter out of logging (across all logs)  Examples could be TranscodingStreams (noticed that it writes so much to logs that it sometimes slows down I/O)","category":"page"},{"location":"man/logger_guide/#Other","page":"Logging","title":"Other","text":"","category":"section"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"For log4j the message string is modified to fit on one line: \\n is replaced by |.","category":"page"},{"location":"man/logger_guide/","page":"Logging","title":"Logging","text":"There is also a path shortener (shorten_path_str) that reduces file paths to a fixed size. The cost is that paths will no longer be clickable, but log messages will start at the same column.","category":"page"},{"location":"lib/internals/#Package-Internals","page":"Package Internals","title":"Package Internals","text":"","category":"section"},{"location":"lib/internals/#BazerUtils-Module","page":"Package Internals","title":"BazerUtils Module","text":"","category":"section"},{"location":"lib/internals/#BazerUtils._dict_of_json3-Tuple{JSON3.Object}","page":"Package Internals","title":"BazerUtils._dict_of_json3","text":"_dict_of_json3(obj::JSON3.Object) -> Dict{Symbol, Any}\n\nRecursively convert a JSON3.Object (from JSON3.jl) into a standard Julia Dict with Symbol keys.\n\nThis function traverses the input JSON3.Object, converting all keys to Symbol and recursively converting any nested JSON3.Object values. Non-object values are left unchanged.\n\nArguments\n\nobj::JSON3.Object: The JSON3 object to convert.\n\nReturns\n\nDict{Symbol, Any}: A Julia dictionary with symbol keys and values converted recursively.\n\nNotes\n\nThis function is intended for internal use and is not exported.\nUseful for converting parsed JSON3 objects into standard Julia dictionaries for easier manipulation.\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#BazerUtils.reformat_msg-Tuple{Any}","page":"Package Internals","title":"BazerUtils.reformat_msg","text":"reformat_msg\n# we view strings as simple and everything else as complex\n\n\n\n\n\n","category":"method"},{"location":"lib/internals/#BazerUtils.shorten_path_str-Tuple{AbstractString}","page":"Package Internals","title":"BazerUtils.shorten_path_str","text":"shorten_path_str(path::AbstractString; max_length::Int=40, strategy::Symbol=:truncate_middle)\n\nShorten a file path string to a specified maximum length using various strategies.\n\nArguments\n\npath::AbstractString: The input path to be shortened\nmax_length::Int=40: Maximum desired length of the output path\nstrategy::Symbol=:truncate_middle: Strategy to use for shortening. Options:\n:no: Return path unchanged\n:truncate_middle: Truncate middle of path components while preserving start/end\n:truncate_to_last: Keep only the last n components of the path\n:truncate_from_right: Progressively remove characters from right side of components\n:truncate_to_unique: Reduce components to unique prefixes\n\nReturns\n\nString: The shortened path\n\nExamples\n\n# Using different strategies\njulia> shorten_path_str(\"/very/long/path/to/file.txt\", max_length=20)\n\"/very/…/path/to/file.txt\"\n\njulia> shorten_path_str(\"/usr/local/bin/program\", strategy=:truncate_to_last, max_length=20)\n\"/bin/program\"\n\njulia> shorten_path_str(\"/home/user/documents/very_long_filename.txt\", strategy=:truncate_middle)\n\"/home/user/doc…ents/very_…name.txt\"\n\n\n\n\n\n","category":"method"},{"location":"man/read_jsonl/#Working-with-JSON-Lines-Files","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"warning: Deprecated\nThe JSONL functions in BazerUtils (read_jsonl, stream_jsonl, write_jsonl) are deprecated. Use JSON.jl v1 instead, which has native support:using JSON\ndata = JSON.parse(\"data.jsonl\"; jsonlines=true)       # read\nJSON.json(\"out.jsonl\", data; jsonlines=true)           # write","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"","category":"page"},{"location":"man/read_jsonl/#From-the-website:-what-is-JSON-Lines?","page":"Working with JSON Lines Files","title":"From the website: what is JSON Lines?","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"JSON Lines (JSONL) is a convenient format for storing structured data that may be processed one record at a time. Each line is a valid JSON value, separated by a newline character. This format is ideal for large datasets and streaming applications.","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"For more details, see jsonlines.org.","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"","category":"page"},{"location":"man/read_jsonl/#Legacy-API-(deprecated)","page":"Working with JSON Lines Files","title":"Legacy API (deprecated)","text":"","category":"section"},{"location":"man/read_jsonl/#read_jsonl","page":"Working with JSON Lines Files","title":"read_jsonl","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"Reads the entire file or stream into memory and returns a vector of parsed JSON values.","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"using BazerUtils\ndata = read_jsonl(\"data.jsonl\")\ndata = read_jsonl(IOBuffer(\"{\\\"a\\\": 1}\\n{\\\"a\\\": 2}\\n\"))\ndata = read_jsonl(IOBuffer(\"{\\\"a\\\": 1}\\n{\\\"a\\\": 2}\\n\"); dict_of_json=true)","category":"page"},{"location":"man/read_jsonl/#stream_jsonl","page":"Working with JSON Lines Files","title":"stream_jsonl","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"Creates a lazy iterator (Channel) that yields one parsed JSON value at a time.","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"for record in stream_jsonl(\"data.jsonl\")\n    println(record)\nend\nfirst10 = collect(Iterators.take(stream_jsonl(\"data.jsonl\"), 10))","category":"page"},{"location":"man/read_jsonl/#write_jsonl","page":"Working with JSON Lines Files","title":"write_jsonl","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"Write an iterable of JSON-serializable values to a JSONL file.","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"write_jsonl(\"out.jsonl\", [Dict(\"a\"=>1), Dict(\"b\"=>2)])\nwrite_jsonl(\"out.jsonl.gz\", (Dict(\"i\"=>i) for i in 1:100); compress=true)","category":"page"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"","category":"page"},{"location":"man/read_jsonl/#See-Also","page":"Working with JSON Lines Files","title":"See Also","text":"","category":"section"},{"location":"man/read_jsonl/","page":"Working with JSON Lines Files","title":"Working with JSON Lines Files","text":"JSON.jl: The recommended replacement. Use jsonlines=true for JSONL support.\nCodecZlib.jl: Gzip compression support.","category":"page"},{"location":"lib/public/#Public-Interface","page":"Public Interface","title":"Public Interface","text":"","category":"section"},{"location":"lib/public/#BazerUtils-Module","page":"Public Interface","title":"BazerUtils Module","text":"","category":"section"},{"location":"lib/public/#BazerUtils.custom_logger-Tuple{BazerUtils.LogSink}","page":"Public Interface","title":"BazerUtils.custom_logger","text":"custom_logger(filename; kw...)\n\nSet up a custom global logger with per-level file output, module filtering, and configurable formatting.\n\nWhen create_log_files=true, creates one log file per level (e.g. filename_error.log, filename_warn.log, etc.). Otherwise all levels write to the same file.\n\nArguments\n\nfilename::AbstractString: base name for the log files\nfiltered_modules_specific::Union{Nothing, Vector{Symbol}}=nothing: modules to filter out of stdout and info-level file logs only (e.g. [:TranscodingStreams])\nfiltered_modules_all::Union{Nothing, Vector{Symbol}}=nothing: modules to filter out of all logs (e.g. [:HTTP])\nfile_loggers::Union{Symbol, Vector{Symbol}}=[:error, :warn, :info, :debug]: which file loggers to register\nlog_date_format::AbstractString=\"yyyy-mm-dd\": date format in log timestamps\nlog_time_format::AbstractString=\"HH:MM:SS\": time format in log timestamps\ndisplaysize::Tuple{Int,Int}=(50,100): display size for non-string log messages\nlog_format::Symbol=:log4j: format for file logs (:log4j, :pretty, or :syslog)\nlog_format_stdout::Symbol=:pretty: format for stdout\nshorten_path::Symbol=:relative_path: path shortening strategy for log4j format\ncreate_log_files::Bool=false: create separate files per log level\noverwrite::Bool=false: overwrite existing log files\ncreate_dir::Bool=false: create the log directory if it doesn't exist\nverbose::Bool=false: warn about filtering non-imported modules\n\nExample\n\ncustom_logger(\"/tmp/myapp\";\n    filtered_modules_all=[:HTTP, :TranscodingStreams],\n    create_log_files=true,\n    overwrite=true,\n    log_format=:log4j)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerUtils.read_jsonl-Tuple{IO}","page":"Public Interface","title":"BazerUtils.read_jsonl","text":"read_jsonl(source::Union{AbstractString, IO}; dict_of_json::Bool=false) -> Vector\n\nwarning: Deprecated\nread_jsonl is deprecated. Use JSON.parse(source; jsonlines=true) from JSON.jl v1 instead.\n\nRead a JSON Lines (.jsonl) file or stream and return all records as a vector.\n\nEach line is parsed as a separate JSON value. Empty lines are skipped.\n\nArguments\n\nsource::Union{AbstractString, IO}: Path to a JSONL file, or an IO stream.\ndict_of_json::Bool=false: If true and the parsed type is JSON3.Object, convert each record to a Dict{Symbol,Any}.\n\nReturns\n\nVector: A vector of parsed JSON values.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerUtils.stream_jsonl-Tuple{IO}","page":"Public Interface","title":"BazerUtils.stream_jsonl","text":"stream_jsonl(source::Union{AbstractString, IO}; T::Type=JSON3.Object{}) -> Channel\n\nwarning: Deprecated\nstream_jsonl is deprecated. Use JSON.parse(source; jsonlines=true) from JSON.jl v1 instead.\n\nCreate a lazy Channel iterator for reading JSON Lines files record by record.\n\nArguments\n\nsource::Union{AbstractString, IO}: Path to a JSONL file, or an IO stream.\nT::Type=JSON3.Object{}: Expected type for each record. Use T=Any for mixed types.\n\nReturns\n\nChannel{T}: A channel yielding parsed JSON objects one at a time.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#BazerUtils.write_jsonl-Tuple{AbstractString, Any, BazerUtils.TableIteration}","page":"Public Interface","title":"BazerUtils.write_jsonl","text":"write_jsonl(filename, data; compress=false)\n\nwarning: Deprecated\nwrite_jsonl is deprecated. Use JSON.json(filename, data; jsonlines=true) from JSON.jl v1 instead.\n\nWrite an iterable of JSON-serializable values to a JSON Lines file.\n\nArguments\n\nfilename: Output file path (writes gzip-compressed if ends with .gz or compress=true)\ndata: An iterable of JSON-serializable values\ncompress::Bool=false: Force gzip compression\n\nReturns\n\nThe filename.\n\n\n\n\n\n","category":"method"},{"location":"#BazerUtils.jl","page":"Home","title":"BazerUtils.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Utility functions for everyday Julia.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Custom Logger: Configurable logging with per-level file output, module filtering, and multiple format options (pretty, log4j, syslog).\nJSON Lines (deprecated): Read/write JSONL files. Use JSON.jl v1 with jsonlines=true instead.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using Pkg\npkg\"registry add https://github.com/LouLouLibs/loulouJL.git\"\nPkg.add(\"BazerUtils\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Or directly from GitHub:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(url=\"https://github.com/LouLouLibs/BazerUtils.jl\")","category":"page"}]
}
